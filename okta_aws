#!/usr/bin/env python
from __future__ import print_function

import base64
import datetime
import getpass
import json
import os
import subprocess
import sys
import time

import requests
import toml
from oktaauth import models

# Renew credentials early
grace_period = 600

class MyOktaSamlAuth(models.OktaSamlAuth):
    """
    The original oktaauth library doesn't deal with getting a new SAML session
    without re-logging into okta, and so we need to override a few things.
    The changes here keep track of the session cookie you get when you
    initially auth with saml, and use that instead of re-logging in each time.
    """
    def __init__(self, okta_url, application_type, application_id):
        models.OktaSamlAuth.__init__(self, okta_url, application_type,
                                     application_id, "", "", "")
        self.session_cookie = None
        self.onetimetoken = None

    def log_into_okta(self, username):
        self.username = username
        print("Okta Username:", username)
        while self.password == "":
            self.password = getpass.getpass("Okta Password: ")
        rv = self.preauth()
        status = rv.get('status', None)
        if 'errorCauses' in rv:
            print("Authentication failed:", rv['errorSummary'])
            print("Authentication failed: ",
                  rv['errorCauses'][0]['errorSummary'])
        elif status == 'SUCCESS':
            self.onetimetoken = rv['sessionToken']
        elif status == 'MFA_ENROLL' or status == 'MFA_ENROLL_ACTIVATE':
            print("You need to enroll an MFA token in okta first.")
        elif status == 'MFA_REQUIRED' or status == 'MFA_CHALLENGE':
            print("MFA Code: ", end='')
            mfacode = sys.stdin.readline().strip()
            tokenids = [f for f in rv['_embedded']['factors'] if
                       f['factorType'] == 'token:software:totp']
            if len(tokenids) == 0:
                print("Error: no TOTP MFA tokens configured with okta")
                return
            mrv = self.doauth(tokenids[0]['id'], rv['stateToken'])
            mstatus = mrv.get('status', None)
            if mstatus == 'SUCCESS':
                self.onetimetoken = rv['sessionToken']
            elif 'errorCauses' in mrv:
                print("MFA Authentication failed: ",
                      mrv['errorCauses'][0]['errorSummary'])
            else:
                print("Unknown MFA error:", mstatus)
        else:
            print("Unknown authentication error:", status)
        return self.onetimetoken

    def get_saml_assertion(self):
        return self.assertion(self.saml())

    def saml(self):
        url = '{base}/app/{app}/{appid}/sso/saml'.format(
            base=self.okta_url,
            app=self.application_type,
            appid=self.application_id)

        params = {}
        if self.onetimetoken is not None:
            # We're logging in for the first time and provided a one time
            # token
            params['onetimetoken'] = self.onetimetoken
            # Reset one time token so we don't reuse it
            self.onetimetoken = None
        resp = requests.get(url=url, params=params, cookies=self.session_cookie)

        if resp.status_code != 200:
            raise Exception('Received error code from server: %s' %
                            resp.status_code)

        if self.session_cookie is None:
            self.session_cookie = resp.cookies

        return resp.text.decode('utf8')

class OktaAWS(object):
    def __init__(self, profile):
        self.profile = profile
        self.config = self.load_config(profile)
        self.okta = None

    def load_config(self, profile):
        fh = open(os.path.expanduser("~/.okta_aws.toml"))
        toml_config = toml.loads(fh.read())
        fh.close()

        toml_config.setdefault('general', {})

        try:
            config = dict(toml_config['general'], **toml_config[profile])
        except KeyError:
            print("Unable to find profile %s in config file" % profile)
            sys.exit(1)

        required_config_options = [
            'username',
            'okta_server',
            'apptype',
            'appid',
            'principal_arn',
            'role_arn'
        ]

        missing_options = [k for k in required_config_options if k not in config]
        if missing_options:
            print("Missing required configuration settings: %s" %
                  ', '.join(missing_options))
            sys.exit(1)
        return config

    def aws_assume_role(self, config, assertion):
        # Get credentials from aws
        output = subprocess.check_output([
            "aws", "sts", "assume-role-with-saml",
            "--role-arn", config['role_arn'],
            "--principal-arn", config['principal_arn'],
            "--saml-assertion", base64.b64encode(assertion)])
        aws_creds = json.loads(output)
        return aws_creds['Credentials']

    def set_aws_config(self, profile, key, value):
        subprocess.call(["aws", "configure", "set",
                         "profile.%s.%s" % (profile, key), value])

    def store_aws_creds_in_profile(self, profile, aws_creds):
        self.set_aws_config(profile, "aws_access_key_id",
                            aws_creds['AccessKeyId'])
        self.set_aws_config(profile, "aws_secret_access_key",
                       aws_creds['SecretAccessKey'])
        self.set_aws_config(profile, "aws_session_token",
                            aws_creds['SessionToken'])


    def calculate_expiration(self, aws_creds):
        expiration = datetime.datetime.strptime(aws_creds['Expiration'],
                                                "%Y-%m-%dT%H:%M:%SZ")
        now = datetime.datetime.utcnow()
        expiration_delta = expiration - now
        # Round down to second boundary (don't include fractions of a second).
        # This makes printing how much time is left a bit neater.
        expiration_delta = datetime.timedelta(
            seconds=int(expiration_delta.total_seconds()))
        return expiration_delta

    def run(self):
        self.okta = MyOktaSamlAuth(self.config['okta_server'],
                                   self.config['apptype'],
                                   self.config['appid'])
        rv = self.okta.log_into_okta(self.config['username'])
        if not rv:
            print("Error logging into okta. Exiting...")
            sys.exit(1)
        while True:
            print("Getting SAML assertion from okta...", end=' ')
            sys.stdout.flush()
            assertion = self.okta.get_saml_assertion()
            if not assertion:
                print("Authentication failed")
                sys.exit(1)
            print("done")
            print("Assuming AWS role...", end=' ')
            sys.stdout.flush()
            aws_creds = self.aws_assume_role(self.config, assertion)
            print("done")
            self.store_aws_creds_in_profile(self.profile, aws_creds)
            print("Temporary credentials stored in profile", self.profile)
            expiration_delta = self.calculate_expiration(aws_creds)
            while expiration_delta.total_seconds() > grace_period:
                print("\rCredentials expire in:", str(expiration_delta), end='')
                sys.stdout.flush()
                time.sleep(1)
                expiration_delta = self.calculate_expiration(aws_creds)
            print()
            print("Renewing credentials")

def usage():
    print("Usage:", sys.argv[0], "[AWSPROFILE]")
    print("Generates temporary AWS credentials for an AWS account you access")
    print("through okta. If you don't specify a profile name, then the")
    print("profile 'default' is used.")
    sys.exit(0)

if __name__ == "__main__":
    if '--help' in sys.argv:
        usage()
    try:
        profile = sys.argv[1]
    except IndexError:
        profile = "default"

    oa = OktaAWS(profile)
    oa.run()
